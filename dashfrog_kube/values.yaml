# Default values for dashfrog_kube.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global configuration
global:
  # Override the chart name.
  nameOverride: ""
  fullnameOverride: ""

# ClickHouse Configuration
clickhouse:
  enabled: true
  replicaCount: 1
  
  image:
    repository: clickhouse/clickhouse-server
    pullPolicy: IfNotPresent
    tag: "latest"
  
  # ClickHouse configuration
  config:
    user: "clickhouse"
    password: "change-me-password"  # MUST be changed in production
    database: "dashfrog"
    port: 9000
    httpPort: 8123
    httpsPort: 8443
  
  # Service configuration
  service:
    type: ClusterIP
    ports:
      clickhouse: 9000
      http: 8123
      https: 8443
  
  # Resources
  resources: {}
    # limits:
    #   cpu: 1000m
    #   memory: 2Gi
    # requests:
    #   cpu: 500m
    #   memory: 1Gi
  
  # Persistent volume
  persistence:
    enabled: true
    size: 10Gi
    storageClass: ""
  
  # Security context
  securityContext:
    runAsUser: 101
    runAsGroup: 101
    fsGroup: 101

# PostgreSQL Configuration
postgresql:
  enabled: true
  replicaCount: 1

  image:
    repository: postgres
    pullPolicy: IfNotPresent
    tag: "16-alpine"

  # PostgreSQL configuration
  config:
    user: "dashfrog"
    password: "change-me-password"  # MUST be changed in production
    database: "dashfrog"
    port: 5432

  # Service configuration
  service:
    type: ClusterIP
    port: 5432

  # Resources
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 1Gi
    # requests:
    #   cpu: 250m
    #   memory: 512Mi

  # Persistent volume
  persistence:
    enabled: true
    size: 10Gi
    storageClass: ""

  # Security context
  securityContext:
    runAsUser: 999
    runAsGroup: 999
    fsGroup: 999

# Prometheus Configuration
prometheus:
  enabled: true
  replicaCount: 1
  
  image:
    repository: prom/prometheus
    pullPolicy: IfNotPresent
    tag: "latest"
  
  # Prometheus configuration
  config:
    scrapeInterval: "15s"
    scrapeTimeout: "10s"
    retention: "15d"
    port: 9090
  
  # Service configuration
  service:
    type: ClusterIP
    port: 9090
  
  # Resources
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 1Gi
    # requests:
    #   cpu: 250m
    #   memory: 512Mi
  
  # Persistent volume
  persistence:
    enabled: true
    size: 5Gi
    storageClass: ""
  
  # Security context
  securityContext:
    runAsUser: 65534
    runAsGroup: 65534
    fsGroup: 65534

# Collector Configuration
collector:
  enabled: true
  replicaCount: 1

  image:
    repository: "ghcr.io/towlabs/dashfrog/collector"  # Must be provided - your custom collector image
    pullPolicy: IfNotPresent
    tag: "latest"

  # Collector configuration
  config:
    # OTLP receiver ports
    otlpGrpcPort: 4317
    otlpHttpPort: 4318
    # Prometheus exporter port
    prometheusPort: 9090
    # Health check port
    healthCheckPort: 13133

  # Service configuration
  service:
    type: ClusterIP
    ports:
      otlpGrpc: 4317
      otlpHttp: 4318
      prometheus: 9090
      healthCheck: 13133

  # Resources
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 1Gi
    # requests:
    #   cpu: 250m
    #   memory: 512Mi

  # Security context
  securityContext:
    runAsUser: 10001
    runAsGroup: 10001
    fsGroup: 10001

# Backend Configuration
backend:
  enabled: true
  replicaCount: 1

  image:
    repository: "ghcr.io/towlabs/dashfrog/backend"  # Your backend image
    pullPolicy: IfNotPresent
    tag: "latest"

  # Backend configuration
  config:
    port: 8080
    env: "production"
    release: "1.0.0"
    # Logging configuration
    logs:
      level: "INFO"
      activateAxiom: false
      logLibs: false

  # Service configuration
  service:
    type: ClusterIP
    port: 8080

  # Resources
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 250m
    #   memory: 256Mi

  # Security context
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000

# Frontend Configuration
frontend:
  enabled: true
  replicaCount: 1

  image:
    repository: "ghcr.io/towlabs/dashfrog/frontend"  # Your frontend image
    pullPolicy: IfNotPresent
    tag: "latest"

  # Frontend configuration
  config:
    port: 8080
    # Backend API URL (will be dynamically set to match backend service name)
    # Format: http://<release-name>-backend:8080
    backendUrl: ""  # Set dynamically in deployment template

  # Service configuration
  service:
    type: ClusterIP
    port: 8080

  # Resources
  resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 256Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # Security context
  securityContext:
    runAsUser: 101
    runAsGroup: 101
    fsGroup: 101

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []

# Service Account Configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# Node selector for all deployments
nodeSelector: {}

# Tolerations for all deployments
tolerations: []

# Affinity for all deployments
affinity: {}

# Ingress configuration
# Ingress provides a single entry point to access both frontend and backend
#
# For local development without a domain:
#   1. Add to /etc/hosts: 127.0.0.1 dashfrog.local
#   2. Port-forward ingress: kubectl port-forward -n ingress-nginx svc/ingress-nginx-controller 8080:80
#   3. Access at: http://dashfrog.local:8080
#
# For production with a domain:
#   1. Set host to your domain (e.g., dashfrog.yourdomain.com)
#   2. Configure TLS with cert-manager or provide your own certificate
#   3. Set ingressClassName to your ingress controller (e.g., nginx, traefik)
ingress:
  enabled: false
  className: "nginx"  # Change to your ingress controller class
  annotations: {}
    # For Let's Encrypt with cert-manager:
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
    # For larger uploads:
    # nginx.ingress.kubernetes.io/proxy-body-size: "10m"
  hosts:
    - host: dashfrog.local  # Change to your domain
      paths:
        # Frontend - serves the React application
        - path: /
          pathType: Prefix
          service:
            name: ""  # Will be set to {{ .Release.Name }}-frontend
            port: 8080
        # Backend API - proxies to backend service
        - path: /api
          pathType: Prefix
          service:
            name: ""  # Will be set to {{ .Release.Name }}-backend
            port: 8080
  tls: []
    # Example TLS configuration:
    # - secretName: dashfrog-tls
    #   hosts:
    #     - dashfrog.local

# HTTPRoute configuration
httpRoute:
  enabled: false
  annotations: {}
  parentRefs:
  - name: gateway
    sectionName: http
  hostnames:
  - chart-example.local
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /

# Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80
